{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"jounetsu","url":""},"pages":[],"posts":[{"title":"Feign","slug":"Feign","date":"2019-01-08T12:42:41.000Z","updated":"2019-01-08T14:11:40.840Z","comments":true,"path":"2019/01/08/Feign/","link":"","permalink":"/2019/01/08/Feign/","excerpt":"","text":"编写Feign客户端增加Feign的起步依赖spring-cloud-starter-feig、Eureka Client的起步依赖spring-cloud-starter-eureka、Web功能的起步依赖spring-boot-starter-web，pom文件如下： 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置application.yml。 123456789server: port: 8765spring: application: name: eureka-feign-clienteureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 在程序启动类EurekFeignClientApplication加上注解@EnableEurekaClient开启Eureka Client的功能，通过注解@EnableFeignClients开启Feign Client的功能。 12345678910@SpringBootApplication@EnableEurekaClient@EnableFeignClientspublic class EurekaFeignClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaFeignClientApplication.class, args); &#125;&#125; 通过以上3个步骤，该程序就具备了Feign的功能。 新建一个EurekaClientFeign的接口，在接口加上@FeignClient来声明一个Feign Client，其中value为远程调用其他服务的服务名，FeignConfig.class为Feign Client的配置类。在接口内部有一个sayHiFromClientEureka()方法，该方法通过Feign来调用eureka-client服务的”/hi”的API接口。 12345@FeignClient(value = \"eureka-client\", configuration = FeignConfig.class)public interface EurekaClientFeign &#123; @GetMapping(value = \"/hi\") String sayHiFromClientEureka(@RequestParam(value = \"name\") String name);&#125; 在FeignConfig类加上@Configuration注解，表明该类是一个配置类，并注入一个BeanName为feignRetryer的Retryer的Bean。注入该Bean之后，Feign在远程调用失败后会进行重试。 123456789import static java.util.concurrent.TimeUnit.SECONDS;@Configurationpublic class FeignConfig &#123; @Bean public Retryer feignRetryer()&#123; return new Retryer.Default(100, SECONDS.toMillis(1), 5); &#125;&#125; 在service层注入EurekaClientFeign的Bean。 12345678910@Servicepublic class HiService &#123; @Autowired EurekaClientFeign eurekaClientFeign; public String sayHi(String name)&#123; return eurekaClientFeign.sayHiFromClientEureka(name); &#125;&#125; 在HiController层注入并调用sayHi()方法。 1234567891011@RestControllerpublic class HiController &#123; @Autowired HiService hiService; @GetMapping(\"/hi\") public String sayHi(@RequestParam(defaultValue = \"zhangsan\", required = false) String name)&#123; return hiService.sayHi(name); &#125;&#125; 访问http://localhost:8765/hi 1hi zhangsan, i am from port 8762 Feign源码实现过程1.首先通过@EnableFeignClients注解开启FeignClient的功能。只有这个注解存在，才会在程序启动时开启对@FeignClient注解的包扫描。 2.根据Feign的规则实现接口，并在接口上面加上@FeignClient注解。 3.程序启动后，会进行包扫描，扫描所有的@FeignClient的注解的类，并将这些信息注入IoC容器中。 4.当接口被调用时，通过JDK的代理来生成具体的RequestTemplate模版对象。 5.根据RequestTemplate再生产Http请求的Request对象。 6.Request对象交给Client去处理，其中Client的网络请求框架可以是HttpURLConnection、HttpClient、OkHttp。 7.最后Client被封装到LoadBalanceClient类，这个类结合类Ribbon做到了负载均衡。 ####","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"/categories/Spring-Cloud/"}],"tags":[]},{"title":"Ribbon","slug":"Ribbon","date":"2019-01-07T13:20:18.000Z","updated":"2019-01-08T12:41:06.141Z","comments":true,"path":"2019/01/07/Ribbon/","link":"","permalink":"/2019/01/07/Ribbon/","excerpt":"","text":"RestTemplateRestTemplate是Spring Resources中一个访问第三方RESTful API接口的网络请求框架。RestTemplate是用来消费REST服务的，所以RestTemplate的主要方法都与REST的Http协议的一些方法紧密相连，例如HEAD、GET、POST、DELETE和OPTIONS等方法，这些方法在RestTemplate类对应的方法为headForHeaders()、getForObject()、postForObject()、put()和delete()等。以下代码可以将返回的JSON字符串转换成一个User对象。 1User user = restTemplate.getForObject(\"https://www.xxx.com/\", User.class); Ribbon负载均衡是指将负载分摊到多个执行单元上，常见的负载均衡有两种方式。一种是独立进程单元，通过负责均衡策略，将请求转发到不同的执行单元上，例如Ngnix。另一种是将负载均衡逻辑以代码的形式封装到服务消费者的客户的，服务消费者客户端维护了一份服务提供者的信息列表。有了信息列表，通过负载均衡策略将请求分摊给多个服务提供者，从而达到负载均衡的目的。 目前NetFlix用于生产环境的Ribbon子模块： ribbon-loadbalancer：可以独立使用或与其他模块一起使用的负载均衡器API。 ribbon-eureka：Ribbon结合Eureka客户端的API，为负载均衡器提供动态服务注册列表。 ribbon-core：Ribbon的核心API。 使用RestTemplate和Ribbon来消费服务引入Eureka Client的起步依赖spring-cloud-starter-eureka、Ribbon的起步依赖spring-cloud-starter-ribbon，以及Web的起步依赖spring-boot-starter-web。 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 配置application.yml，指定程序名、端口号、服务注册地址。 123456789spring: application: name: eureka-ribbon-clientserver: port: 8764eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 作为Eureka Client需要在程序的入口类加上注解@EnableEurekaClient开启Eureka Client功能。 123456789@SpringBootApplication@EnableEurekaClientpublic class EurekaRibbonClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaRibbonClientApplication.class, args); &#125;&#125; 写一个RESTful API接口，在该API接口内部需要调用eureka-client的API接口”/hi”，即服务消费。这时需要将RestTemplate和Ribbon相结合，进行负载均衡。 需要在程序的IoC容器中注入一个restTemplate的Bean，并在这个Bean上加上@LoadBalanced注解，此时RestTemplate就结合了Ribbon开启了负载均衡功能。 12345678@Configurationpublic class RibbonConfig &#123; @Bean @LoadBalanced RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 写一个RibbonService类，在该类的hi()方法用restTemplate调用eureka-client的API接口，此时Uri不需要使用硬编码(如ip)，只需要写服务名即可。 123456789@Servicepublic class RibbonService &#123; @Autowired RestTemplate restTemplate; public String hi(String name)&#123; return restTemplate.getForObject(\"http://eureka-client/hi?name=\"+name, String.class); &#125;&#125; 写RibbonController，调用servcie的方法。 123456789101112@RestControllerpublic class RibbonController &#123; @Autowired RibbonService ribbonService; @GetMapping(\"/hi\") public String hi(@RequestParam(required = false, defaultValue = \"zhangsan\") String name)&#123; return ribbonService.hi(name); &#125;&#125; LoadBalanceClient负载均衡器的核心类为LoadBalanceClient，LoadBalanceClient可以获取负载均衡的服务提供者的实例信息。 获取Eureka Client的实例信息时： 123456789101112@RestControllerpublic class RibbonController &#123; @Autowired private LoadBalancerClient loadBalancerClient; @GetMapping(\"/testRibbon\") public String testRibbon()&#123; ServiceInstance instance = loadBalancerClient.choose(\"eureka-client\"); return instance.getHost() + \":\" + instance.getPort(); &#125;&#125; 不从Eureka Client获取注册列表信息时： 在启动类中增加@SpringBootApplication注解。 配置文件application.yml，配置ribbon.eureka.enable为false来禁止调用Eureka Client获取注册列表。配置程序名为stores的服务，通过stores.ribbon.listOfServers来配置这些服务实例的Url。 12345678stores: ribbon: listOfServers: example.com,google.comribbon: eureka: enabled: falseserver: port: 8769 新建RestController类。 123456789101112@RestControllerpublic class RibbonController &#123; @Autowired private LoadBalancerClient loadBalancerClient; @GetMapping(\"/testRibbon\") public String testRibbon()&#123; ServiceInstance instance = loadBalancerClient.choose(\"stores\"); return instance.getHost() + \":\" + instance.getPort(); &#125;&#125; 在浏览器上多次访问http://localhost:8769/testRibbon，浏览器会交替出现以下内容： 12example.com:80google.com:80 在Ribbon中的负载均衡客户端为LoadBalancerClient，在Spring Cloud项目中，负载均衡器Ribbon会默认从Eureka Client的服务注册列表中获取服务的信息，并缓存一份。如果禁止从Eureka获取注册列表信息，则需要自己维护一份服务注册列表信息。","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"/categories/Spring-Cloud/"}],"tags":[]},{"title":"Eureka","slug":"Eureka","date":"2019-01-05T13:13:26.000Z","updated":"2019-01-06T11:51:07.239Z","comments":true,"path":"2019/01/05/Eureka/","link":"","permalink":"/2019/01/05/Eureka/","excerpt":"","text":"Eureka简介什么是EurekaEureka是一个用于服务注册和发现的组件。Eureka分为Eureka Server和Eureka Client，Eureka Server为Eureka服务注册中心，Eureka Client为Eureka客户端。 Eureka的基本架构主要包括以下3种角色 Register Service:：服务注册中心，它是一个Eureka Server，提供服务注册和发现的功能 Provide Service：服务提供者，它是一个Eureka Client，提供服务 Consumer Service：服务消费者，它是一个Eureka Client，消费服务 Eureka Server在pom文件中引入Eureka Server依赖 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在application.yml中做配置。通过server.port制定Eureka Server的端口为8761。在默认情况下，Eureka Server 会向自己注册，这时需要配置eureka.client.registerWithEurkea和eureka.client.fetchRegistry为false，防止自己注册自己。 1234567891011server: port: 8761eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 在工程的启动类EurekaServerApplication加上注解@EnableEurekaServer，开启Eureka Server的功能。 123456789@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; Eureka Client在pom中引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 在bootstrap.yml做Eureka Client客户端的相关配置，配置了程序名为eureka-client，程序端口为8762，服务注册地址为http://localhost:8761/eureka/ 123456789server: port: 8762spring: application: name: eureka-clienteureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka 在程序的启动类加上@EnableEurekaClient开启Eureka Client功能 123456789@SpringBootApplication@EnableEurekaClientpublic class EurekaClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaClientApplication.class, args); &#125;&#125; Eureka概念 Register–服务注册 当Eureka Client向Eureka Server注册时，Eureka Client提供自身的元数据，比如IP地址、端口、运行状况指标的Url、主页地址等信息。 Renew–服务续约 Eureka Client在默认的情况下会每隔30秒发送一次心跳来进行服务续约。通过服务续约来告知Eureka Server该Eureka Client仍然可用，没有出现故障。 Fetch Registries–获取服务注册列表信息 Eureka Client从Eureka Server获取服务注册表信息，并将其缓存在本地。 Cancel–服务下线 Eureka Client在程序关闭时可以向Eureka Server发送下线请求。发送请求后，该客户端的实例信息将从Eureka Server的服务注册列表中删除。该下线请求不会自动完成，需要在程序中调用: 1DiscoveryManager.getInstance().shutdownComponent(); Eviction–服务剔除 在默认情况下，当Eureka Client连续90秒没有向Eureka Server发送服务续约(即心跳)时，Eureka Server会将该服务实例从服务注册列表中删除。","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"/categories/Spring-Cloud/"}],"tags":[]},{"title":"Spring Boot","slug":"Spring-Boot","date":"2018-12-17T13:44:39.000Z","updated":"2019-01-05T14:10:39.215Z","comments":true,"path":"2018/12/17/Spring-Boot/","link":"","permalink":"/2018/12/17/Spring-Boot/","excerpt":"","text":"@SpringBootApplication注解@SpringBootApplication开启了Spring的组件扫描和Spring Boot的自动配置功能呢。实际上，它将三个有用的注解组合在了一起。 @Configuration:标明该类使用Spring基于Java的配置。 @ComponentScan:启用组件扫描。 @EnableAutoConfiguration:开启自动配置。","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"/categories/Spring-Boot/"}],"tags":[]}]}