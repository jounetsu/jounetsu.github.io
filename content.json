{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"jounetsu","url":""},"pages":[],"posts":[{"title":"(三)Java内存模型","slug":"Java内存模型","date":"2019-03-22T07:11:55.000Z","updated":"2019-03-22T07:12:53.542Z","comments":true,"path":"2019/03/22/Java内存模型/","link":"","permalink":"/2019/03/22/Java内存模型/","excerpt":"","text":"","categories":[{"name":"并发编程笔记","slug":"并发编程笔记","permalink":"/categories/并发编程笔记/"}],"tags":[]},{"title":"(二)Java并发机制的底层实现原理","slug":"Java并发机制的底层实现原理","date":"2019-03-19T01:40:17.000Z","updated":"2019-03-22T07:12:16.265Z","comments":true,"path":"2019/03/19/Java并发机制的底层实现原理/","link":"","permalink":"/2019/03/19/Java并发机制的底层实现原理/","excerpt":"","text":"volatile定义​ Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。 实现原则1）Lock前缀指令会引起处理器缓存回写到内存。 2）一个处理器的缓存回写到内存会导致其他处理器的缓存无效。 Synchronized利用Synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现在以下三种形式。 对于普通同步方法，锁是当前实例对象。 对于静态同步方法，锁是当前类的Class对象。 对于同步方法块，锁是Synchronized括号里配置的对象。 Java对象头​ synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个自宽(Word)存储对象头，如果对象是非数组类型，则用2自宽存储。在32位虚拟机中，1字宽澄宇4字节，即32bit。 ​ Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。在运行期间，Mark Word里存储的数据会随着锁标记位的变化而变化。 锁的升级与对比​ 锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。 偏向锁​ 大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块获取锁时，会在对象头和栈桢中的锁记录里存储锁偏向的线程ID，以后该进程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。 偏向锁的撤销​ 偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。 关闭偏向锁​ 默认为启用状态，在应用程序启动几秒钟后才激活，可使用JVM参数来关闭延迟:-XX:BiasedLockingStartupDelay=0。确定如果程序里所有的锁通常情况下处于竞争状态，可通过JVM参数关闭偏向锁:-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。 轻量级锁轻量级锁加锁​ 线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。 轻量级锁解锁​ 轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前存在锁竞争，锁就会膨胀成重量级锁。","categories":[{"name":"并发编程笔记","slug":"并发编程笔记","permalink":"/categories/并发编程笔记/"}],"tags":[]},{"title":"设计模式","slug":"设计模式","date":"2019-03-03T07:20:28.000Z","updated":"2019-03-03T14:05:09.367Z","comments":true,"path":"2019/03/03/设计模式/","link":"","permalink":"/2019/03/03/设计模式/","excerpt":"","text":"观察者模式定义观察者模式定义了对象之间的的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 Java内置的观察者模式把对象编程观察者实现观察者接口（java.util.Observer），然后调用任何Observable对象的addObserver()方法。不想再当观察者时，调用deleteObserver()方法。 可观察者送出通知首先利用java.util.Observable接口产生“可观察者”类，然后，需要两个步骤： 先调用setChanged()方法，标记状态已经改变的事实。 然后调用两种notifyObservers()方法中的一个：notifyObservers()或notifyObservers(Object arg) 观察者接收通知实现update(Observable o, Object arg)。主题本身当作第一个变量，好让观察者知道是哪个主题通知它的。第二个参数是传入notifyObservers()的数据对象，如果没有则为空。 装饰者模式定义装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 装饰者和被装饰对象有相同的超类型 你可以用一个或多个装饰者包装一个对象 既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象代替它 装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象 工厂模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"/categories/设计模式/"}],"tags":[]},{"title":"Zuul","slug":"Zuul","date":"2019-02-14T13:25:44.000Z","updated":"2019-02-14T14:58:24.545Z","comments":true,"path":"2019/02/14/Zuul/","link":"","permalink":"/2019/02/14/Zuul/","excerpt":"","text":"为什么需要ZuulZuul作为路由网关组件体现在以下6个方面： Zuul、Ribbon以及Eureak相结合，可以实现智能路由和负载均衡的功能，Zuul能够将请求流量按某种策略分发到集群状态的多个服务实例。 网关将所有服务的API接口统一聚合，并统一对外暴露。 网关服务可以做用户身份认证和权限认证，防止非法请求操作API接口，对服务器起到保护作用。 网关可以实现监控功能，实时日志输出，对请求进行记录。 网关可以用来实现流量监控，在高流量的情况下，对服务进行降级。 API接口从内部服务分离出来，方便做测试。 Zuul的工作原理Zuul是通过Servlet实现的，Zuul通过自定义的ZuulServlet（类似于Spring MVC的DispatchServlet）来对请求进行控制。Zuul的核心是一系列过滤器，可以在Http请求的发起和响应返回期间执行一系列的过滤器。包括以下4种过滤器。 PRE过滤器：它是在请求路由到具体的服务之前执行的，这种类型的过滤器可以做安全验证，例如身份验证、参数验证等。 ROUTING过滤器：它用于将请求路由到具体的微服务实例。默认情况下使用Http Client进行网络请求。 POST过滤器：它是在请求已被路由到微服务后执行的。一般情况下，用作收集统计信息、指标，以及将响应传输到客户端。 ERROR过滤器：它是在其他过滤发生错误时执行的。 搭建Zuul服务引入Eureka Client的起步依赖spring-cloud-starter-eureka、Zuul的起步依赖spring-cloud-starter-zuul、Web功能的起步依赖spring-boot-starter-web以及Spring Boot测试的起步依赖spring-boot-starter-test，pom文件如下 1234567891011121314151617181920&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在程序的启动类EurekaZuulClientApplication加上@EnableEurekaClient注解，开启EurekaClient的功能；加上@EnableZuulProxy注解，开启Zuul的功能。 12345678910@EnableZuulProxy@EnableEurekaClient@SpringBootApplicationpublic class EurekaZuulClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaZuulClientApplication.class, args); &#125;&#125; 在application.yml中配置，配置注册中心eureka-client，程序端口号5000，程序名为servicce-zuul，zuul.routes.hiapi.path为“/hiapi/**”，zuul.routes.hiapi.serviceId为“eureka-client”，这两个配置就可以将以”/hiapi”开头的Url路由到eureka-client服务。 1234567891011121314151617181920eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/server: port: 5000spring: application: name: service-zuulzuul: routes: hiapi: path: /hiapi/** serviceId: eureka-client ribbonapi: path: /rubbibapi/** serviceId: eureka-ribbon-client feignapi: path: /feignapi/** serviceId: eureka-feign-client 在Zuul上配置API接口的版本号，只需在application.yml中增加 1zuul.prefix: /v1 在Zuul上配置熔断器，需实现ZuulFallbackProvider接口。实现该接口有两个方法，一个是getRoute()方法，用于指定熔断功能应用于哪些路由的服务；另一个方法fallbackResponse()为进入熔断功能时执行的逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Componentpublic class MyFallbackProvider implements ZuulFallbackProvider &#123; @Override public String getRoute()&#123; return \"eureka-client\"; &#125; @Override public ClientHttpResponse fallbackResponse() &#123; return new ClientHttpResponse() &#123; @Override public HttpStatus getStatusCode() throws IOException &#123; return HttpStatus.OK; &#125; @Override public int getRawStatusCode() throws IOException &#123; return 200; &#125; @Override public String getStatusText() throws IOException &#123; return \"OK\"; &#125; @Override public void close() &#123; &#125; @Override public InputStream getBody() throws IOException &#123; return new ByteArrayInputStream(\"oooops!error, i'm the fallback.\".getBytes()); &#125; @Override public HttpHeaders getHeaders() &#123; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); return headers; &#125; &#125;; &#125;&#125; 在Zuul上使用过滤器，需要继承ZuulFilter，并实现其中的抽象方法，包括filterType()和filterOrder()以及IZuulFilter的shouldFilter()和object run()的两个方法。其中，filterType()即过滤器的类型，分别是“pre””post””routing”和”error”。filterOrder()是过滤顺序，它为一个Int类型的值，值越小，越早执行该过滤器。shouldFilter()表示该过滤器是否过滤逻辑，如果为true，则执行run()方法；false为不执行。run()方法写具体的过滤的逻辑。 12345678910111213141516171819202122232425262728293031323334353637@Componentpublic class MyFilter extends ZuulFilter &#123; private static Logger log = LoggerFactory.getLogger(MyFilter.class); @Override public String filterType() &#123; return PRE_TYPE; &#125; @Override public int filterOrder() &#123; return 0; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() &#123; RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); Object accessToken = request.getParameter(\"token\"); if(accessToken == null)&#123; log.warn(\"token is empty\"); ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); try&#123; ctx.getResponse().getWriter().write(\"token is empty\"); &#125;catch (Exception e)&#123; return null; &#125; &#125; log.info(\"ok\"); return null; &#125;&#125;","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"/categories/Spring-Cloud/"}],"tags":[]},{"title":"Hystrix","slug":"Hystrix","date":"2019-01-09T13:46:58.000Z","updated":"2019-01-09T15:37:18.047Z","comments":true,"path":"2019/01/09/Hystrix/","link":"","permalink":"/2019/01/09/Hystrix/","excerpt":"","text":"HystrixHystrix是Netflix公司开源的一个项目，它提供了熔断器功能，能够阻止分布式系统中出现联动故障。Hystrix是通过隔离服务的访问点阻止联动故障的，并提供了故障的解决方法，从而提高了整个分布式系统的弹性。 Hystrix的设计原则 防止单个服务的故障耗尽整个服务的Servlet容器(如Tomcat)的线程资源。 快速失败机制，如果某个服务出现了故障，则调用该服务的请求快速失败，而不是线程等待。 提供回退方案，在请求发生故障时，提供设定好的回退方案。 使用熔断机制，防止故障扩散到其他服务。 提供熔断器的监控组件Hystrix Dashboard，可以实时监控熔断器的状态。 Hystrix的工作机制当服务的某个API接口的失败次数在一定时间内小于设定的阀值时，熔断器处于关闭状态，该API接口正常提供服务。当该API接口处理请求的失败次数大于阀值时，Hystrix判断该API接口出现了故障，打开熔断器，这时请求该API接口会执行快速失败的逻辑(即fallback回退的逻辑)，不执行业务逻辑，请求的线程不会处于阻塞状态。处于打开状态的熔断器，一段时间后会处于半打开状态，并将一定数量的请求执行正常逻辑。剩余的请求会执行快速失败，若执行正常逻辑的请求失败了，则熔断器继续打开；若成功了，则将熔断器关闭。 在RestTemplate和Ribbon上使用熔断器在pom文件中引入Hystrix的起步依赖spring-cloud-starter-hystrix 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类加上@EnableHystrix注解开启Hystrix的熔断器功能 12345678910@SpringBootApplication@EnableEurekaClient@EnableHystrixpublic class EurekaRibbonClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaRibbonClientApplication.class, args); &#125;&#125; 修改RibbonService，在hi()方法上加@HystrixCommand注解。有了该注解，hi()方法就启用了Hystrix熔断器的功能。fallbackMethod为处理回退逻辑的方法。在熔断器打开的状态下，会执行fallback逻辑。fallback的逻辑最好是返回一些静态的字符串，不需要处理复杂的逻辑，也不需要远程调度其他服务，这样方便执行快速失败，释放线程资源。如果一定要在fallback逻辑中远程调度其他服务，最好在远程调度其他服务时，也加上熔断器。 1234567891011121314@Servicepublic class RibbonService &#123; @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = \"hiError\") public String hi(String name)&#123; return restTemplate.getForObject(\"http://eureka-client/hi?name=\"+name, String.class); &#125; public String hiError(String name)&#123; return \"hi,\" + name + \",sorry,sorry!\"; &#125;&#125; 在Feign上使用熔断器在Feign的起步依赖已经引入了Hystrix的依赖，只需要在application.yml配置开启Hystrix的功能。 123feign: hystrix: enabled: true 修改EurekaClientFeign代码，在@FeignClient注解的fallback配置加上快速失败的处理类。 12345@FeignClient(value = \"eureka-client\", configuration = FeignConfig.class, fallback = HyStrix.class)public interface EurekaClientFeign &#123; @GetMapping(value = \"/hi\") String sayHiFromClientEureka(@RequestParam(value = \"name\") String name);&#125; Hystrix类需要实现EurekaCLientFeign接口，并写具体逻辑，以及加上@Component注解，注入IoC容器中。 1234567@Componentpublic class HyStrix implements EurekaClientFeign&#123; @Override public String sayHiFromClientEureka(String name) &#123; return \"hi,\" + name + \",sorry,sorry!\"; &#125;&#125; 使用Hystrix Dashboard监控熔断器的状态在pom文件中加上Actuator、Hystrix Dashboard和Hystrix的起步依赖。 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; 在程序的启动类加上@EnableHystrixDashboard注解。 1234567891011@SpringBootApplication@EnableEurekaClient@EnableHystrix@EnableHystrixDashboardpublic class EurekaRibbonClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaRibbonClientApplication.class, args); &#125;&#125; 使用Turbine聚合监控添加依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-turbine&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 1234567891011121314spring: application.name: service-turbineserver: port: 8769security.basic.enabled: falseturbine: aggregator: clusterConfig: default appConfig: eureka-ribbon-client,eureka-feign-client clusterNameExpression: new String(&quot;default&quot;)eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ turbine.appConfig ：配置Eureka中的serviceId列表，表明监控哪些服务 turbine.aggregator.clusterConfig ：指定聚合哪些集群，多个使用”,”分割，默认为default。可使用http://.../turbine.stream?cluster={clusterConfig之一}访问 turbine.clusterNameExpression ： 1. clusterNameExpression指定集群名称，默认表达式appName；此时：turbine.aggregator.clusterConfig需要配置想要监控的应用名称；2. 当clusterNameExpression: default时，turbine.aggregator.clusterConfig可以不写，因为默认就是default；3. 当clusterNameExpression: metadata[‘cluster’]时，假设想要监控的应用配置了eureka.instance.metadata-map.cluster: ABC，则需要配置，同时turbine.aggregator.clusterConfig: ABC 启动类添加@EnableTurbine，激活对Turbine的支持 123456789@SpringBootApplication@EnableTurbinepublic class EurekaMonitorClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaMonitorClientApplication.class, args); &#125;&#125;","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"/categories/Spring-Cloud/"}],"tags":[]},{"title":"Feign","slug":"Feign","date":"2019-01-08T12:42:41.000Z","updated":"2019-01-09T13:47:14.516Z","comments":true,"path":"2019/01/08/Feign/","link":"","permalink":"/2019/01/08/Feign/","excerpt":"","text":"编写Feign客户端增加Feign的起步依赖spring-cloud-starter-feig、Eureka Client的起步依赖spring-cloud-starter-eureka、Web功能的起步依赖spring-boot-starter-web，pom文件如下： 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置application.yml。 123456789server: port: 8765spring: application: name: eureka-feign-clienteureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 在程序启动类EurekFeignClientApplication加上注解@EnableEurekaClient开启Eureka Client的功能，通过注解@EnableFeignClients开启Feign Client的功能。 12345678910@SpringBootApplication@EnableEurekaClient@EnableFeignClientspublic class EurekaFeignClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaFeignClientApplication.class, args); &#125;&#125; 通过以上3个步骤，该程序就具备了Feign的功能。 新建一个EurekaClientFeign的接口，在接口加上@FeignClient来声明一个Feign Client，其中value为远程调用其他服务的服务名，FeignConfig.class为Feign Client的配置类。在接口内部有一个sayHiFromClientEureka()方法，该方法通过Feign来调用eureka-client服务的”/hi”的API接口。 12345@FeignClient(value = \"eureka-client\", configuration = FeignConfig.class)public interface EurekaClientFeign &#123; @GetMapping(value = \"/hi\") String sayHiFromClientEureka(@RequestParam(value = \"name\") String name);&#125; 在FeignConfig类加上@Configuration注解，表明该类是一个配置类，并注入一个BeanName为feignRetryer的Retryer的Bean。注入该Bean之后，Feign在远程调用失败后会进行重试。 123456789import static java.util.concurrent.TimeUnit.SECONDS;@Configurationpublic class FeignConfig &#123; @Bean public Retryer feignRetryer()&#123; return new Retryer.Default(100, SECONDS.toMillis(1), 5); &#125;&#125; 在service层注入EurekaClientFeign的Bean。 12345678910@Servicepublic class HiService &#123; @Autowired EurekaClientFeign eurekaClientFeign; public String sayHi(String name)&#123; return eurekaClientFeign.sayHiFromClientEureka(name); &#125;&#125; 在HiController层注入并调用sayHi()方法。 1234567891011@RestControllerpublic class HiController &#123; @Autowired HiService hiService; @GetMapping(\"/hi\") public String sayHi(@RequestParam(defaultValue = \"zhangsan\", required = false) String name)&#123; return hiService.sayHi(name); &#125;&#125; 访问http://localhost:8765/hi 1hi zhangsan, i am from port 8762 Feign源码实现过程1.首先通过@EnableFeignClients注解开启FeignClient的功能。只有这个注解存在，才会在程序启动时开启对@FeignClient注解的包扫描。 2.根据Feign的规则实现接口，并在接口上面加上@FeignClient注解。 3.程序启动后，会进行包扫描，扫描所有的@FeignClient的注解的类，并将这些信息注入IoC容器中。 4.当接口被调用时，通过JDK的代理来生成具体的RequestTemplate模版对象。 5.根据RequestTemplate再生产Http请求的Request对象。 6.Request对象交给Client去处理，其中Client的网络请求框架可以是HttpURLConnection、HttpClient、OkHttp。 7.最后Client被封装到LoadBalanceClient类，这个类结合类Ribbon做到了负载均衡。","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"/categories/Spring-Cloud/"}],"tags":[]},{"title":"Ribbon","slug":"Ribbon","date":"2019-01-07T13:20:18.000Z","updated":"2019-01-08T12:41:06.141Z","comments":true,"path":"2019/01/07/Ribbon/","link":"","permalink":"/2019/01/07/Ribbon/","excerpt":"","text":"RestTemplateRestTemplate是Spring Resources中一个访问第三方RESTful API接口的网络请求框架。RestTemplate是用来消费REST服务的，所以RestTemplate的主要方法都与REST的Http协议的一些方法紧密相连，例如HEAD、GET、POST、DELETE和OPTIONS等方法，这些方法在RestTemplate类对应的方法为headForHeaders()、getForObject()、postForObject()、put()和delete()等。以下代码可以将返回的JSON字符串转换成一个User对象。 1User user = restTemplate.getForObject(\"https://www.xxx.com/\", User.class); Ribbon负载均衡是指将负载分摊到多个执行单元上，常见的负载均衡有两种方式。一种是独立进程单元，通过负责均衡策略，将请求转发到不同的执行单元上，例如Ngnix。另一种是将负载均衡逻辑以代码的形式封装到服务消费者的客户的，服务消费者客户端维护了一份服务提供者的信息列表。有了信息列表，通过负载均衡策略将请求分摊给多个服务提供者，从而达到负载均衡的目的。 目前NetFlix用于生产环境的Ribbon子模块： ribbon-loadbalancer：可以独立使用或与其他模块一起使用的负载均衡器API。 ribbon-eureka：Ribbon结合Eureka客户端的API，为负载均衡器提供动态服务注册列表。 ribbon-core：Ribbon的核心API。 使用RestTemplate和Ribbon来消费服务引入Eureka Client的起步依赖spring-cloud-starter-eureka、Ribbon的起步依赖spring-cloud-starter-ribbon，以及Web的起步依赖spring-boot-starter-web。 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 配置application.yml，指定程序名、端口号、服务注册地址。 123456789spring: application: name: eureka-ribbon-clientserver: port: 8764eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 作为Eureka Client需要在程序的入口类加上注解@EnableEurekaClient开启Eureka Client功能。 123456789@SpringBootApplication@EnableEurekaClientpublic class EurekaRibbonClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaRibbonClientApplication.class, args); &#125;&#125; 写一个RESTful API接口，在该API接口内部需要调用eureka-client的API接口”/hi”，即服务消费。这时需要将RestTemplate和Ribbon相结合，进行负载均衡。 需要在程序的IoC容器中注入一个restTemplate的Bean，并在这个Bean上加上@LoadBalanced注解，此时RestTemplate就结合了Ribbon开启了负载均衡功能。 12345678@Configurationpublic class RibbonConfig &#123; @Bean @LoadBalanced RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 写一个RibbonService类，在该类的hi()方法用restTemplate调用eureka-client的API接口，此时Uri不需要使用硬编码(如ip)，只需要写服务名即可。 123456789@Servicepublic class RibbonService &#123; @Autowired RestTemplate restTemplate; public String hi(String name)&#123; return restTemplate.getForObject(\"http://eureka-client/hi?name=\"+name, String.class); &#125;&#125; 写RibbonController，调用servcie的方法。 123456789101112@RestControllerpublic class RibbonController &#123; @Autowired RibbonService ribbonService; @GetMapping(\"/hi\") public String hi(@RequestParam(required = false, defaultValue = \"zhangsan\") String name)&#123; return ribbonService.hi(name); &#125;&#125; LoadBalanceClient负载均衡器的核心类为LoadBalanceClient，LoadBalanceClient可以获取负载均衡的服务提供者的实例信息。 获取Eureka Client的实例信息时： 123456789101112@RestControllerpublic class RibbonController &#123; @Autowired private LoadBalancerClient loadBalancerClient; @GetMapping(\"/testRibbon\") public String testRibbon()&#123; ServiceInstance instance = loadBalancerClient.choose(\"eureka-client\"); return instance.getHost() + \":\" + instance.getPort(); &#125;&#125; 不从Eureka Client获取注册列表信息时： 在启动类中增加@SpringBootApplication注解。 配置文件application.yml，配置ribbon.eureka.enable为false来禁止调用Eureka Client获取注册列表。配置程序名为stores的服务，通过stores.ribbon.listOfServers来配置这些服务实例的Url。 12345678stores: ribbon: listOfServers: example.com,google.comribbon: eureka: enabled: falseserver: port: 8769 新建RestController类。 123456789101112@RestControllerpublic class RibbonController &#123; @Autowired private LoadBalancerClient loadBalancerClient; @GetMapping(\"/testRibbon\") public String testRibbon()&#123; ServiceInstance instance = loadBalancerClient.choose(\"stores\"); return instance.getHost() + \":\" + instance.getPort(); &#125;&#125; 在浏览器上多次访问http://localhost:8769/testRibbon，浏览器会交替出现以下内容： 12example.com:80google.com:80 在Ribbon中的负载均衡客户端为LoadBalancerClient，在Spring Cloud项目中，负载均衡器Ribbon会默认从Eureka Client的服务注册列表中获取服务的信息，并缓存一份。如果禁止从Eureka获取注册列表信息，则需要自己维护一份服务注册列表信息。","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"/categories/Spring-Cloud/"}],"tags":[]},{"title":"Eureka","slug":"Eureka","date":"2019-01-05T13:13:26.000Z","updated":"2019-01-06T11:51:07.239Z","comments":true,"path":"2019/01/05/Eureka/","link":"","permalink":"/2019/01/05/Eureka/","excerpt":"","text":"Eureka简介什么是EurekaEureka是一个用于服务注册和发现的组件。Eureka分为Eureka Server和Eureka Client，Eureka Server为Eureka服务注册中心，Eureka Client为Eureka客户端。 Eureka的基本架构主要包括以下3种角色 Register Service:：服务注册中心，它是一个Eureka Server，提供服务注册和发现的功能 Provide Service：服务提供者，它是一个Eureka Client，提供服务 Consumer Service：服务消费者，它是一个Eureka Client，消费服务 Eureka Server在pom文件中引入Eureka Server依赖 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在application.yml中做配置。通过server.port制定Eureka Server的端口为8761。在默认情况下，Eureka Server 会向自己注册，这时需要配置eureka.client.registerWithEurkea和eureka.client.fetchRegistry为false，防止自己注册自己。 1234567891011server: port: 8761eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 在工程的启动类EurekaServerApplication加上注解@EnableEurekaServer，开启Eureka Server的功能。 123456789@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; Eureka Client在pom中引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 在bootstrap.yml做Eureka Client客户端的相关配置，配置了程序名为eureka-client，程序端口为8762，服务注册地址为http://localhost:8761/eureka/ 123456789server: port: 8762spring: application: name: eureka-clienteureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka 在程序的启动类加上@EnableEurekaClient开启Eureka Client功能 123456789@SpringBootApplication@EnableEurekaClientpublic class EurekaClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaClientApplication.class, args); &#125;&#125; Eureka概念 Register–服务注册 当Eureka Client向Eureka Server注册时，Eureka Client提供自身的元数据，比如IP地址、端口、运行状况指标的Url、主页地址等信息。 Renew–服务续约 Eureka Client在默认的情况下会每隔30秒发送一次心跳来进行服务续约。通过服务续约来告知Eureka Server该Eureka Client仍然可用，没有出现故障。 Fetch Registries–获取服务注册列表信息 Eureka Client从Eureka Server获取服务注册表信息，并将其缓存在本地。 Cancel–服务下线 Eureka Client在程序关闭时可以向Eureka Server发送下线请求。发送请求后，该客户端的实例信息将从Eureka Server的服务注册列表中删除。该下线请求不会自动完成，需要在程序中调用: 1DiscoveryManager.getInstance().shutdownComponent(); Eviction–服务剔除 在默认情况下，当Eureka Client连续90秒没有向Eureka Server发送服务续约(即心跳)时，Eureka Server会将该服务实例从服务注册列表中删除。","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"/categories/Spring-Cloud/"}],"tags":[]},{"title":"Spring Boot","slug":"Spring-Boot","date":"2018-12-17T13:44:39.000Z","updated":"2019-01-05T14:10:39.215Z","comments":true,"path":"2018/12/17/Spring-Boot/","link":"","permalink":"/2018/12/17/Spring-Boot/","excerpt":"","text":"@SpringBootApplication注解@SpringBootApplication开启了Spring的组件扫描和Spring Boot的自动配置功能呢。实际上，它将三个有用的注解组合在了一起。 @Configuration:标明该类使用Spring基于Java的配置。 @ComponentScan:启用组件扫描。 @EnableAutoConfiguration:开启自动配置。","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"/categories/Spring-Boot/"}],"tags":[]}]}