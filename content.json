{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"jounetsu","url":""},"pages":[],"posts":[{"title":"(七)Java中的并发工具类","slug":"Java中的并发工具类","date":"2019-04-09T08:16:06.000Z","updated":"2019-04-10T07:42:50.409Z","comments":true,"path":"2019/04/09/Java中的并发工具类/","link":"","permalink":"/2019/04/09/Java中的并发工具类/","excerpt":"","text":"等待多线程完成的CountDownLatch​ CountDownLatch允许一个或多个线程等待其他线程完成操作。 12345678910111213141516public class CountDownLatchTest &#123; public static void main(String[] args) throws Exception&#123; CountDownLatch c = new CountDownLatch(2); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(1); c.countDown(); System.out.println(2); c.countDown(); &#125; &#125;).start(); c.await(); System.out.println(\"3\"); &#125;&#125; ​ CountDonwLatch的构造函数接收一个int类型的参数作为计数器，如果想等待N个点完成，就传入N。 ​ 计数器必须大于等于0，只是等于0的时候，计数器就是零，调用await方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。一个线程调用countDown方法happen-before，另外一个线程调用await方法。 同步屏障CyclicBarrier​ CyclicBarrier要做的事情是，让一组线程到达一个屏障(也可以叫同步点)时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。 1234567891011121314151617181920212223242526public class CyclicBarrierTest &#123; public static void main(String[] args) &#123; CyclicBarrier c = new CyclicBarrier(2); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; c.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(1); &#125; &#125;).start(); try &#123; c.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(2); &#125;&#125; ​ 因为主线程和子线程的调度是由CPU决定的，两个线程都有可能先执行。如果把new CyclicBarrier(2)修改成new CyclicBarrier(3)，则主线程和子线程会永远等待，因为没有第三个线程执行await方法，即没有第三个线程到达屏障，所以之前到达屏障的两个线程都不会继续执行。 1234567891011121314151617181920212223242526272829303132public class CyclicBarrierTest2 &#123; public static void main(String[] args) &#123; CyclicBarrier c = new CyclicBarrier(2, new A()); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; c.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(1); &#125; &#125;).start(); try &#123; c.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(2); &#125; static class A implements Runnable&#123; @Override public void run() &#123; System.out.println(3); &#125; &#125;&#125; ​ 因为CyclicBarrier设置了拦截线程的数量是2，所以必须等代码中的第一个线程和线程A都执行完后，才会继续执行主线程，然后输出2。 控制并发线程数的Semaphore​ Semaphore是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。 12345678910111213141516171819202122public class SemaphoreTest &#123; private static final int THREAD_COUNT = 30; private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT); private static Semaphore s = new Semaphore(10); public static void main(String[] args) &#123; for (int i = 0; i &lt; THREAD_COUNT; i++) &#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; s.acquire(); System.out.println(\"save data\"); s.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; threadPool.shutdown(); &#125;&#125; ​ 虽然有30个线程在执行，但是只允许10个并发执行。Semaphore的构造方法Semaphore(int permits)接受一个整型的数字，表示可用的许可证数量。Semaphore的用法很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。 线程间交换数据的Exchanger​ Exchanger是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一致等待第二个线程也执行exchange方法，当两个线程到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。 12345678910111213141516171819202122232425262728293031public class ExchangerTest &#123; public static void main(String[] args) &#123; Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;(); ExecutorService threadPool = Executors.newFixedThreadPool(2); threadPool.execute(new Runnable() &#123; @Override public void run() &#123; //A录入银行流水数据 String A = \"银行流水A\"; try &#123; exchanger.exchange(A); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); threadPool.execute(new Runnable() &#123; @Override public void run() &#123; String B = \"银行流水B\"; try &#123; String A = exchanger.exchange(\"B\"); System.out.println(\"A和B数据是否一致:\" + A.equals(B) + \",A录入的是:\" + A + \",B录入的是\" + B); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); threadPool.shutdown(); &#125;&#125;","categories":[{"name":"并发编程笔记","slug":"并发编程笔记","permalink":"/categories/并发编程笔记/"}],"tags":[]},{"title":"(六)Java中的12个原子操作类","slug":"Java中的12个原子操作类","date":"2019-04-09T03:39:46.000Z","updated":"2019-04-09T08:16:38.767Z","comments":true,"path":"2019/04/09/Java中的12个原子操作类/","link":"","permalink":"/2019/04/09/Java中的12个原子操作类/","excerpt":"","text":"原子更新基本类型类​ 使用原子的方式更新基本类型，Atomic包提供了以下3个类。 AtomicBoolean：原子更新布尔型 AtomicInteger：原子更新整型 AtomicLong：原子更新长整型 12345678910public class AtomicIntegerTest &#123; public static void main(String[] args) &#123; AtomicInteger atomicInteger = new AtomicInteger(1); System.out.println(atomicInteger.getAndIncrement()); System.out.println(atomicInteger.get()); atomicInteger.addAndGet(5); System.out.println(atomicInteger.get()); &#125;&#125; 原子更新数组​ 通过原子的方式更新数组里的某个元素，Atomic包提供了以下3个类。 AtomicIntegerArray：原子更新整型数组里的元素 AtomicLongArray：原子更新长整型数组里的元素 AtmoicReferenceArray：原子更新引用类型数组里的元素 12345678910public class AtomicIntegerArrayTest &#123; public static void main(String[] args) &#123; int[] value = new int[]&#123;1, 2&#125;; AtomicIntegerArray integerArray = new AtomicIntegerArray(value); integerArray.getAndSet(0, 3); System.out.println(integerArray.get(0)); System.out.println(value[0]); &#125;&#125; ​ 数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组。 原子更新引用类型​ 原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。 AtomicReference：原子更新引用类型 AtomicReferenceFieldUpdater：原子更新引用类型里的字段 AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型 12345678910111213141516171819202122232425public class AtomicReferenceTest &#123; public static void main(String[] args) &#123; AtomicReference&lt;User&gt; userAtomicReference = new AtomicReference&lt;&gt;(); User user = new User(\"张三\", 18); userAtomicReference.set(user); User updateUser = new User(\"李四\", 20); userAtomicReference.compareAndSet(user, updateUser); System.out.println(userAtomicReference.get().getName()); System.out.println(userAtomicReference.get().getOld()); &#125; static class User&#123; private String name; private int old; public User(String name, int old)&#123; this.name = name; this.old = old; &#125; public String getName() &#123; return name; &#125; public int getOld() &#123; return old; &#125; &#125;&#125; 原子更新字段类​ 如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新。 AtomicIntegerFieldUpdater：原子更新整型的字段的更新器 AtomicLongFieldUpdate：原子更新整型字段的更新器 AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题 要想原子地更新字段需要两步。第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新类的字段(属性)必须使用public volatile修饰符。 12345678910111213141516171819202122public class AtomicIntegerFieldUpdaterTest &#123; public static void main(String[] args) &#123; AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, \"old\"); User user = new User(\"张三\", 18); System.out.println(a.getAndIncrement(user)); System.out.println(a.get(user)); &#125; public static class User &#123; private String name; public volatile int old; public User(String name, int old) &#123; this.name = name; this.old = old; &#125; public String getName() &#123; return name; &#125; public int getOld() &#123; return old; &#125; &#125;&#125;","categories":[{"name":"并发编程笔记","slug":"并发编程笔记","permalink":"/categories/并发编程笔记/"}],"tags":[]},{"title":"(五)Java并发容器和框架","slug":"Java并发容器和框架","date":"2019-04-03T06:20:05.000Z","updated":"2019-04-09T03:38:45.576Z","comments":true,"path":"2019/04/03/Java并发容器和框架/","link":"","permalink":"/2019/04/03/Java并发容器和框架/","excerpt":"","text":"ConcurrentHashMap的实现原理与使用ConcurrentHashMap的结构​ ConcurrentHashMap是由Segment数组结构和HashEntry数据结构组成。Segment是一种可重入锁(ReentrantLock)，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。 ConcurrentHashMap的操作1.get操作 ​ Segment的get操作实现非常简单和高校。先经过一次再散列，然后使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素。get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空才会加锁重读。因为get方法里将要使用的共享变量都定义为volatile类型。 2.put操作 ​ 由于put方法里需要对共享变量进行写入操作，所以为了线程安全。在操作共享变量时必须加锁。put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数据进行扩容，第二步定位添加元素的位置，然后将其放在HashEntry数组里。 Fork/Join框架工作窃取算法​ 工作窃取算法是指某个线程从其他队列里窃取任务来执行。 ​ 工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。 ​ 工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。 Fork/Join框架的异常处理​ ForkJoinTask在执行的时候可能会抛出异常，但是没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。 ​ getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。 Fork/Join框架的实现原理​ ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责将存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务。","categories":[{"name":"并发编程笔记","slug":"并发编程笔记","permalink":"/categories/并发编程笔记/"}],"tags":[]},{"title":"(四)Java中的锁","slug":"Java中的锁","date":"2019-04-01T02:00:49.000Z","updated":"2019-04-03T06:18:34.798Z","comments":true,"path":"2019/04/01/Java中的锁/","link":"","permalink":"/2019/04/01/Java中的锁/","excerpt":"","text":"Lock接口​ 锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。 ​ Lock的使用： 1234567Lock lock = new ReentrantLock();lock.lock();tyr&#123;&#125; finally&#123;lock.unlock();&#125; ​ 在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。 ​ 不要将获取锁的过程写在try块中，因为如果在获取锁(自定义锁的实现)时发生了异常，异常抛出的同时，也会导致锁无故释放。 ​ Lock接口提供的synchronized关键字所不具备的主要特性。 特性 描述 尝试非阻塞地获取锁 当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁 能被中断地获取锁 与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放 超时获取锁 在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回 ​ Lock是一个接口，它定义了锁获取和释放的基本操作。 方法名称 描述 void lock() 获取锁，调用该方法当前线程将会获取锁，当锁获得后，从该方法返回 void lockInterruptibly() throws InterruptedException 可中断地获取锁，和lock()方法的不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程 boolean tryLock() 尝试非阻塞的获取锁，调用该方法后立刻返回，如果能够获取则返回true，否则返回false boolean tryLock(long time, TimeUnit unit) throws InterruptedException 超时的获取锁，当前线程在以下3种情况下会返回：1.当前线程在超时时间内获得了锁 2.当前线程在超时时间内被中断 3.超时时间结束，返回false void unlock() 释放锁 Condition newCondition() 获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的wait()方法，而调用后，当前线程将释放锁 队列同步器​ 队列同步器AbstractQueuedSynchronized，是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。 同步队列​ 同步器依赖内部的同步队列(一个FIFO双向队列)来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。 ​ 同步队列中的节点用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点。 独占式同步状态获取与释放​ 通过调用同步器的acquire(int arg)方法可以获取同步状态，该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移出。 ​ 当前线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，使得后续节点能够继续获取同步状态。通过调用同步器的release(int arg)方法可以释放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点(进而使后继节点重新尝试获取同步状态)。 共享式同步状态获取与释放​ 通过调用同步器的acquireShared(int arg)方法可以共享式地获取同步状态。通过调用realeaseShared(int arg)方法可以释放同步状态。 重入锁​ 重入锁ReentrantLock，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁还支持获取锁时的公平和非公平选择。 读写锁​ 读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。 特性 说明 公平性选择 支持非公平(默认)和公平的锁获取方式，吞吐量还是非公平优于公平 重进入 该锁支持重进入，以读写线程为例：读线程在获取了读锁之后，能够再次获取读锁。而写线程在获取了写锁之后能够再次获取读写锁，同时也可以获取读锁 锁降级 遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁 写锁的获取与释放​ 写锁是一个支持重进入的排他锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取(读状态不为0)或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。 ​ 写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。 读锁的获取释放​ 读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问(或者写状态为0)时，读锁总会被成功地获取，而所做的也只是(线程安全的)增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。 锁降级​ 锁降级指的是写锁降级成为读锁。锁降级是指把持住(当前拥有的)写锁，再获取到读锁，随后释放(先前拥有的)写锁的过程。 Condition接口​ Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。Condition对象时由Lock对象(调用Lock对象的newCondition()方法)创建出来的，Condition是依赖Lock对象的。 等待队列​ 等待队列是一个FIFO的队列，在队列的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程会释放锁、构造成节点加入等待队列并进入等待状态。 等待​ 调用Condition的await()方法，会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。 通知​ 调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点(首节点)，在唤醒节点之前，会将节点移到同步队列中。","categories":[{"name":"并发编程笔记","slug":"并发编程笔记","permalink":"/categories/并发编程笔记/"}],"tags":[]},{"title":"(三)Java并发编程基础","slug":"Java并发编程基础","date":"2019-03-28T13:28:20.000Z","updated":"2019-04-01T02:00:12.109Z","comments":true,"path":"2019/03/28/Java并发编程基础/","link":"","permalink":"/2019/03/28/Java并发编程基础/","excerpt":"","text":"线程简介线程优先级​ 现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。 ​ 在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1～10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞(休眠或者I/O操作)的线程需要设置较高优先级，而偏重计算(需要较多CPU时间或者偏运算)的线程舍之间较低的优先级，确保处理器不会被独占。在不同的JVM以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定。 线程状态 状态名称 说明 NEW 初始状态，线程被构建，但是还没有调用start()方法 RUNNABLE 运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作”运行中” BLOCKED 阻塞状态，表示线程阻塞于锁 WAITING 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断) TIME_WATING 超时等待状态，该状态不同于WATING，它是可以在指定的时间自行返回的 TERMINATED 终止状态，表示当前线程已经执行完毕 Daemon线程​ Dameon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。 ​ Daemon线程需要在启动线程之前设置，不能在启动线程之后设置。 ​ Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。 启动和终止线程启动线程​ 线程对象在初始化完成之后，调用start()方法就可以启动这个线程。线程start()方法的含义是：当前线程(即parent线程)同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。 理解中断​ 中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。其他线程通过调用该线程的interrupt()方法对其进行中断操作。 ​ 线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrupted()对当前线程的中断标识位进行复位。如果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧会返回false。 安全地终止线程​ 中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。 1234567891011121314151617181920212223242526272829303132333435public class ShutDown &#123; public static void main(String[] args) throws Exception&#123; Runner one = new Runner(); Thread countThread = new Thread(one, \"CountThread\"); countThread.start(); //睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束 TimeUnit.SECONDS.sleep(1); countThread.interrupt(); Runner two = new Runner(); countThread = new Thread(two, \"CountThread\"); countThread.start(); //睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束 TimeUnit.SECONDS.sleep(1); two.cancel(); &#125; private static class Runner implements Runnable &#123; private long i; private volatile boolean on = true; public void run() &#123; while (on &amp;&amp; !Thread.currentThread().isInterrupted()) &#123; i++; &#125; System.out.println(\"Count i = \" + i); &#125; public void cancel() &#123; on = false; &#125; &#125;&#125; 线程间通信volatile和synchronized关键字​ 关键字volatile可以用来修饰字段(成员变量)，就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。 ​ 关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。 等待/通知机制 方法名称 描述 notify() 通知一个在对象上等待的线程，使其从wait()方法返回，而返回的前提是该线程获取到了对象的锁 notifyAll() 通知所有等待在该对象上的线程 wait() 调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意，调用wait()方法后，会释放对象的锁 wait(long) 超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回 wait(long,int) 对于超时时间更细粒度的控制，可以达到纳秒 ​ 等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态， 而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 等待/通知 * */public class WaitNotify &#123; static boolean flag = true; static Object lock = new Object(); public static void main(String[] args) throws Exception &#123; Thread waitThread = new Thread(new Wait(), \"WaitThread\"); waitThread.start(); TimeUnit.SECONDS.sleep(1); Thread notifyThread = new Thread(new Notify(), \"NotifyThread\"); notifyThread.start(); &#125; static class Wait implements Runnable &#123; @Override public void run() &#123; //加锁，拥有lock的monitor synchronized (lock) &#123; //当条件不满足时，继续wait，同时释放了lock的锁 while (flag) &#123; try &#123; System.out.println(Thread.currentThread() + \" flag is true. wait @ \" + LocalTime.now()); lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //条件满足时，完成工作 System.out.println(Thread.currentThread() + \" flag is false. running @ \" + LocalTime.now()); &#125; &#125; &#125; static class Notify implements Runnable &#123; @Override public void run() &#123; //加锁，拥有lock的monitor synchronized (lock) &#123; //获取lock的锁，然后进行通知，通知时不会释放lock的锁 //直到当前线程释放了lock后，waitThread才能从wait方法中返回 System.out.println(Thread.currentThread() + \" hold lock. notify @ \" + LocalTime.now()); lock.notifyAll(); flag = false; SleepUtils.second(5); &#125; //再次加锁 synchronized (lock) &#123; System.out.println(Thread.currentThread() + \" hold lock again. sleep @ \" + LocalTime.now()); SleepUtils.second(5); &#125; &#125; &#125;&#125; 管道输入/输出流​ 管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。 ​ 管道输入/输出流主要包括了4种具体实现:PipedOutputStream、PipedInputStream、PipedReader和PipedWriter，前两种面向字节，后两种面向字符。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 管道输入/输出流 * */public class Piped &#123; public static void main(String[] args) throws Exception &#123; PipedWriter out = new PipedWriter(); PipedReader in = new PipedReader(); //将输出流和输入流进行连接，否则在使用时会抛出IOException out.connect(in); Thread printThread = new Thread(new Print(in), \"PrintThread\"); printThread.start(); int receive = 0; try &#123; while ((receive = System.in.read()) != -1) &#123; out.write(receive); &#125; &#125; finally &#123; out.close(); &#125; &#125; static class Print implements Runnable &#123; private PipedReader in; public Print(PipedReader in) &#123; this.in = in; &#125; @Override public void run() &#123; int receive = 0; try &#123; while ((receive = in.read()) != -1) &#123; System.out.print((char) receive); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; ​ 对于Piped类型的流，必须先要进行绑定，也就是调用connec()方法，如果没有将输入/输出流绑定起来，对于该流的访问将会抛出异常。 Thread.join()的使用​ 如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后从thread.join()返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。这两个超时方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。 123456789101112131415161718192021222324252627282930313233343536/** * join方法 * */public class Join &#123; public static void main(String[] args) throws Exception &#123; Thread previous = Thread.currentThread(); for (int i = 0; i &lt; 10; i++) &#123; Thread thread = new Thread(new Domino(previous), String.valueOf(i)); thread.start(); previous = thread; &#125; TimeUnit.SECONDS.sleep(5); System.out.println(Thread.currentThread().getName() + \" terminate.\"); &#125; static class Domino implements Runnable &#123; private Thread thread; public Domino(Thread thread) &#123; this.thread = thread; &#125; @Override public void run() &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" terminate.\"); &#125; &#125;&#125; ThreadLocal的使用​ ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先的值。 123456789101112131415161718192021222324252627/** * ThreadLocal使用 * */public class Profiler &#123; //第一次get()方法调用时会进行初始化(如果set方法没有调用)，每个线程会调用一次 private static final ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = new ThreadLocal&lt;&gt;() &#123; @Override protected Long initialValue() &#123; return System.currentTimeMillis(); &#125; &#125;; public static final void begin() &#123; TIME_THREADLOCAL.set(System.currentTimeMillis()); &#125; public static final long end() &#123; return System.currentTimeMillis() - TIME_THREADLOCAL.get(); &#125; public static void main(String[] args) throws Exception &#123; Profiler.begin(); TimeUnit.SECONDS.sleep(1); System.out.println(\"Cost: \" + Profiler.end() + \" mills\"); &#125;&#125; ​ Profiler可以被复用在方法调用耗时统计的功能上，在方法的入口前执行begin()方法，在方法调用后执行end()方法，好处是两个方法的调用不用在一个方法或者类中。","categories":[{"name":"并发编程笔记","slug":"并发编程笔记","permalink":"/categories/并发编程笔记/"}],"tags":[]},{"title":"(三)Java内存模型","slug":"Java内存模型","date":"2019-03-22T07:11:55.000Z","updated":"2019-03-28T13:33:31.876Z","comments":true,"path":"2019/03/22/Java内存模型/","link":"","permalink":"/2019/03/22/Java内存模型/","excerpt":"","text":"Java内存模型的基础Java内存模型的抽象结构​ 在Java中，所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。局部变量，方法定义参数和异常处理器参数不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。 ​ Java线程之间的通信由Java内存模型(JMM)控制，JMM定义了一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。 从源代码到指令序列的重排序 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作上看上去可能是在乱序执行。 顺序一致性顺序一致性内存模型两大特性： 一个线程中的所有操作必须按照程序的顺序来执行。 不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。 未同步程序的执行顺序​ JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。 ​ 未同步程序在JMM的执行时，整体上是无序的，其执行结果无法预知。未同步程序在两个模型中的执行特性有如下几个差异。 顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行（比如正确同步的多线程程序在临界区内的重排序）。 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。 JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。 volatile的内存语义volatile的特性 可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。 原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种符合操作不具有原子性。 volatile写-读的内存语义写的语义如下：当写入一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。 读的语义如下：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。 volatile内存语义的实现 在每个volatile写操作的前面插入一个StoreStore屏障。 在每个volatile写操作的后面插入一个StoreLoad屏障。 在每个volatile读操作的后面插入一个LoadLoad屏障。 在每个volatile读操作的后面插入一个LoadStore屏障。 锁的内存含义锁的释放和获取的内存含义 当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。 当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。 锁内存语义的实现12345678910111213141516171819202122232425public class ReentrantLockExample &#123; int a = 0; ReentrantLock lock = new ReentrantLock(); public void writer()&#123; //获取锁 lock.lock(); try &#123; a++; &#125; finally &#123; //释放锁 lock.unlock(); &#125; &#125; public void reader()&#123; //获取锁 lock.lock(); try &#123; int i = a; //方法 &#125; finally &#123; //释放锁 lock.unlock(); &#125; &#125;&#125; ​ 在ReentrantLock中，调用lock()方法获取锁；调用unlock()方法释放锁。 ​ ReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronizer。AQS使用一个整型的volatile变量(命名为state)来维护同步状态。 公平锁和非公平锁释放时，最后都要写一个volatile变量state。 公平锁获取时，首先会去读volatile变量。 非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。 final域的内存含义final域的重排序规则 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，让这两个操作之间不能重排序。 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。 写final域的重排序规则​ 写final域的重排序规则禁止把final域的写重排序到构造函数之外。这个规则的实现包含下面2个方面。 JMM禁止编译器把final域的写重排序到构造函数之外。 编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。 ​ 写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。 读final域的重排序规则​ 读final域的重排序规则是，在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作(仅针对处理器)。编译器会在读final域操作的前面插入一个LoadLoad屏障。 ​ 读final域的重排序规则可以确保：在读一个对象的final域之前，一定会读包含这个final域的对象的引用。 happens-beforehappens-before的定义 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这么重排序并不非法(JMM允许这种重排序)。 happnes-before规则happens-before规则如下： 程序员顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作 监视器规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。 start()规则：如果线程A执行操作ThreadB.start()(启动线程)，那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。 join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从Thread.join()操作成功返回。 类初始化 通过在Class对象上同步(即获取Class对象的初始化锁)，来控制类或接口的初始化。这个获取锁的线程会一直等待，直到当前线程能够获取到这个初始化锁。 线程A执行类的初始化，同时线程B在初始化锁对应的Condition上等待。 线程A设置state=initialized，然后唤醒在condition中等待的所有线程。 线程B结束类的初始化处理。 线程C执行类的初始化的处理。 JMM的内存可见性保证 单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。 正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性(程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同)。这时JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。 未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值(0、null、false)。","categories":[{"name":"并发编程笔记","slug":"并发编程笔记","permalink":"/categories/并发编程笔记/"}],"tags":[]},{"title":"(二)Java并发机制的底层实现原理","slug":"Java并发机制的底层实现原理","date":"2019-03-19T01:40:17.000Z","updated":"2019-03-22T07:12:16.265Z","comments":true,"path":"2019/03/19/Java并发机制的底层实现原理/","link":"","permalink":"/2019/03/19/Java并发机制的底层实现原理/","excerpt":"","text":"volatile定义​ Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。 实现原则1）Lock前缀指令会引起处理器缓存回写到内存。 2）一个处理器的缓存回写到内存会导致其他处理器的缓存无效。 Synchronized利用Synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现在以下三种形式。 对于普通同步方法，锁是当前实例对象。 对于静态同步方法，锁是当前类的Class对象。 对于同步方法块，锁是Synchronized括号里配置的对象。 Java对象头​ synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个自宽(Word)存储对象头，如果对象是非数组类型，则用2自宽存储。在32位虚拟机中，1字宽澄宇4字节，即32bit。 ​ Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。在运行期间，Mark Word里存储的数据会随着锁标记位的变化而变化。 锁的升级与对比​ 锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。 偏向锁​ 大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块获取锁时，会在对象头和栈桢中的锁记录里存储锁偏向的线程ID，以后该进程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。 偏向锁的撤销​ 偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。 关闭偏向锁​ 默认为启用状态，在应用程序启动几秒钟后才激活，可使用JVM参数来关闭延迟:-XX:BiasedLockingStartupDelay=0。确定如果程序里所有的锁通常情况下处于竞争状态，可通过JVM参数关闭偏向锁:-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。 轻量级锁轻量级锁加锁​ 线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。 轻量级锁解锁​ 轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前存在锁竞争，锁就会膨胀成重量级锁。","categories":[{"name":"并发编程笔记","slug":"并发编程笔记","permalink":"/categories/并发编程笔记/"}],"tags":[]},{"title":"设计模式","slug":"设计模式","date":"2019-03-03T07:20:28.000Z","updated":"2019-03-03T14:05:09.367Z","comments":true,"path":"2019/03/03/设计模式/","link":"","permalink":"/2019/03/03/设计模式/","excerpt":"","text":"观察者模式定义观察者模式定义了对象之间的的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 Java内置的观察者模式把对象编程观察者实现观察者接口（java.util.Observer），然后调用任何Observable对象的addObserver()方法。不想再当观察者时，调用deleteObserver()方法。 可观察者送出通知首先利用java.util.Observable接口产生“可观察者”类，然后，需要两个步骤： 先调用setChanged()方法，标记状态已经改变的事实。 然后调用两种notifyObservers()方法中的一个：notifyObservers()或notifyObservers(Object arg) 观察者接收通知实现update(Observable o, Object arg)。主题本身当作第一个变量，好让观察者知道是哪个主题通知它的。第二个参数是传入notifyObservers()的数据对象，如果没有则为空。 装饰者模式定义装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 装饰者和被装饰对象有相同的超类型 你可以用一个或多个装饰者包装一个对象 既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象代替它 装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象 工厂模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"/categories/设计模式/"}],"tags":[]},{"title":"Zuul","slug":"Zuul","date":"2019-02-14T13:25:44.000Z","updated":"2019-02-14T14:58:24.545Z","comments":true,"path":"2019/02/14/Zuul/","link":"","permalink":"/2019/02/14/Zuul/","excerpt":"","text":"为什么需要ZuulZuul作为路由网关组件体现在以下6个方面： Zuul、Ribbon以及Eureak相结合，可以实现智能路由和负载均衡的功能，Zuul能够将请求流量按某种策略分发到集群状态的多个服务实例。 网关将所有服务的API接口统一聚合，并统一对外暴露。 网关服务可以做用户身份认证和权限认证，防止非法请求操作API接口，对服务器起到保护作用。 网关可以实现监控功能，实时日志输出，对请求进行记录。 网关可以用来实现流量监控，在高流量的情况下，对服务进行降级。 API接口从内部服务分离出来，方便做测试。 Zuul的工作原理Zuul是通过Servlet实现的，Zuul通过自定义的ZuulServlet（类似于Spring MVC的DispatchServlet）来对请求进行控制。Zuul的核心是一系列过滤器，可以在Http请求的发起和响应返回期间执行一系列的过滤器。包括以下4种过滤器。 PRE过滤器：它是在请求路由到具体的服务之前执行的，这种类型的过滤器可以做安全验证，例如身份验证、参数验证等。 ROUTING过滤器：它用于将请求路由到具体的微服务实例。默认情况下使用Http Client进行网络请求。 POST过滤器：它是在请求已被路由到微服务后执行的。一般情况下，用作收集统计信息、指标，以及将响应传输到客户端。 ERROR过滤器：它是在其他过滤发生错误时执行的。 搭建Zuul服务引入Eureka Client的起步依赖spring-cloud-starter-eureka、Zuul的起步依赖spring-cloud-starter-zuul、Web功能的起步依赖spring-boot-starter-web以及Spring Boot测试的起步依赖spring-boot-starter-test，pom文件如下 1234567891011121314151617181920&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在程序的启动类EurekaZuulClientApplication加上@EnableEurekaClient注解，开启EurekaClient的功能；加上@EnableZuulProxy注解，开启Zuul的功能。 12345678910@EnableZuulProxy@EnableEurekaClient@SpringBootApplicationpublic class EurekaZuulClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaZuulClientApplication.class, args); &#125;&#125; 在application.yml中配置，配置注册中心eureka-client，程序端口号5000，程序名为servicce-zuul，zuul.routes.hiapi.path为“/hiapi/**”，zuul.routes.hiapi.serviceId为“eureka-client”，这两个配置就可以将以”/hiapi”开头的Url路由到eureka-client服务。 1234567891011121314151617181920eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/server: port: 5000spring: application: name: service-zuulzuul: routes: hiapi: path: /hiapi/** serviceId: eureka-client ribbonapi: path: /rubbibapi/** serviceId: eureka-ribbon-client feignapi: path: /feignapi/** serviceId: eureka-feign-client 在Zuul上配置API接口的版本号，只需在application.yml中增加 1zuul.prefix: /v1 在Zuul上配置熔断器，需实现ZuulFallbackProvider接口。实现该接口有两个方法，一个是getRoute()方法，用于指定熔断功能应用于哪些路由的服务；另一个方法fallbackResponse()为进入熔断功能时执行的逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Componentpublic class MyFallbackProvider implements ZuulFallbackProvider &#123; @Override public String getRoute()&#123; return \"eureka-client\"; &#125; @Override public ClientHttpResponse fallbackResponse() &#123; return new ClientHttpResponse() &#123; @Override public HttpStatus getStatusCode() throws IOException &#123; return HttpStatus.OK; &#125; @Override public int getRawStatusCode() throws IOException &#123; return 200; &#125; @Override public String getStatusText() throws IOException &#123; return \"OK\"; &#125; @Override public void close() &#123; &#125; @Override public InputStream getBody() throws IOException &#123; return new ByteArrayInputStream(\"oooops!error, i'm the fallback.\".getBytes()); &#125; @Override public HttpHeaders getHeaders() &#123; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); return headers; &#125; &#125;; &#125;&#125; 在Zuul上使用过滤器，需要继承ZuulFilter，并实现其中的抽象方法，包括filterType()和filterOrder()以及IZuulFilter的shouldFilter()和object run()的两个方法。其中，filterType()即过滤器的类型，分别是“pre””post””routing”和”error”。filterOrder()是过滤顺序，它为一个Int类型的值，值越小，越早执行该过滤器。shouldFilter()表示该过滤器是否过滤逻辑，如果为true，则执行run()方法；false为不执行。run()方法写具体的过滤的逻辑。 12345678910111213141516171819202122232425262728293031323334353637@Componentpublic class MyFilter extends ZuulFilter &#123; private static Logger log = LoggerFactory.getLogger(MyFilter.class); @Override public String filterType() &#123; return PRE_TYPE; &#125; @Override public int filterOrder() &#123; return 0; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() &#123; RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); Object accessToken = request.getParameter(\"token\"); if(accessToken == null)&#123; log.warn(\"token is empty\"); ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); try&#123; ctx.getResponse().getWriter().write(\"token is empty\"); &#125;catch (Exception e)&#123; return null; &#125; &#125; log.info(\"ok\"); return null; &#125;&#125;","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"/categories/Spring-Cloud/"}],"tags":[]},{"title":"Hystrix","slug":"Hystrix","date":"2019-01-09T13:46:58.000Z","updated":"2019-01-09T15:37:18.047Z","comments":true,"path":"2019/01/09/Hystrix/","link":"","permalink":"/2019/01/09/Hystrix/","excerpt":"","text":"HystrixHystrix是Netflix公司开源的一个项目，它提供了熔断器功能，能够阻止分布式系统中出现联动故障。Hystrix是通过隔离服务的访问点阻止联动故障的，并提供了故障的解决方法，从而提高了整个分布式系统的弹性。 Hystrix的设计原则 防止单个服务的故障耗尽整个服务的Servlet容器(如Tomcat)的线程资源。 快速失败机制，如果某个服务出现了故障，则调用该服务的请求快速失败，而不是线程等待。 提供回退方案，在请求发生故障时，提供设定好的回退方案。 使用熔断机制，防止故障扩散到其他服务。 提供熔断器的监控组件Hystrix Dashboard，可以实时监控熔断器的状态。 Hystrix的工作机制当服务的某个API接口的失败次数在一定时间内小于设定的阀值时，熔断器处于关闭状态，该API接口正常提供服务。当该API接口处理请求的失败次数大于阀值时，Hystrix判断该API接口出现了故障，打开熔断器，这时请求该API接口会执行快速失败的逻辑(即fallback回退的逻辑)，不执行业务逻辑，请求的线程不会处于阻塞状态。处于打开状态的熔断器，一段时间后会处于半打开状态，并将一定数量的请求执行正常逻辑。剩余的请求会执行快速失败，若执行正常逻辑的请求失败了，则熔断器继续打开；若成功了，则将熔断器关闭。 在RestTemplate和Ribbon上使用熔断器在pom文件中引入Hystrix的起步依赖spring-cloud-starter-hystrix 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类加上@EnableHystrix注解开启Hystrix的熔断器功能 12345678910@SpringBootApplication@EnableEurekaClient@EnableHystrixpublic class EurekaRibbonClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaRibbonClientApplication.class, args); &#125;&#125; 修改RibbonService，在hi()方法上加@HystrixCommand注解。有了该注解，hi()方法就启用了Hystrix熔断器的功能。fallbackMethod为处理回退逻辑的方法。在熔断器打开的状态下，会执行fallback逻辑。fallback的逻辑最好是返回一些静态的字符串，不需要处理复杂的逻辑，也不需要远程调度其他服务，这样方便执行快速失败，释放线程资源。如果一定要在fallback逻辑中远程调度其他服务，最好在远程调度其他服务时，也加上熔断器。 1234567891011121314@Servicepublic class RibbonService &#123; @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = \"hiError\") public String hi(String name)&#123; return restTemplate.getForObject(\"http://eureka-client/hi?name=\"+name, String.class); &#125; public String hiError(String name)&#123; return \"hi,\" + name + \",sorry,sorry!\"; &#125;&#125; 在Feign上使用熔断器在Feign的起步依赖已经引入了Hystrix的依赖，只需要在application.yml配置开启Hystrix的功能。 123feign: hystrix: enabled: true 修改EurekaClientFeign代码，在@FeignClient注解的fallback配置加上快速失败的处理类。 12345@FeignClient(value = \"eureka-client\", configuration = FeignConfig.class, fallback = HyStrix.class)public interface EurekaClientFeign &#123; @GetMapping(value = \"/hi\") String sayHiFromClientEureka(@RequestParam(value = \"name\") String name);&#125; Hystrix类需要实现EurekaCLientFeign接口，并写具体逻辑，以及加上@Component注解，注入IoC容器中。 1234567@Componentpublic class HyStrix implements EurekaClientFeign&#123; @Override public String sayHiFromClientEureka(String name) &#123; return \"hi,\" + name + \",sorry,sorry!\"; &#125;&#125; 使用Hystrix Dashboard监控熔断器的状态在pom文件中加上Actuator、Hystrix Dashboard和Hystrix的起步依赖。 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; 在程序的启动类加上@EnableHystrixDashboard注解。 1234567891011@SpringBootApplication@EnableEurekaClient@EnableHystrix@EnableHystrixDashboardpublic class EurekaRibbonClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaRibbonClientApplication.class, args); &#125;&#125; 使用Turbine聚合监控添加依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-turbine&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 1234567891011121314spring: application.name: service-turbineserver: port: 8769security.basic.enabled: falseturbine: aggregator: clusterConfig: default appConfig: eureka-ribbon-client,eureka-feign-client clusterNameExpression: new String(&quot;default&quot;)eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ turbine.appConfig ：配置Eureka中的serviceId列表，表明监控哪些服务 turbine.aggregator.clusterConfig ：指定聚合哪些集群，多个使用”,”分割，默认为default。可使用http://.../turbine.stream?cluster={clusterConfig之一}访问 turbine.clusterNameExpression ： 1. clusterNameExpression指定集群名称，默认表达式appName；此时：turbine.aggregator.clusterConfig需要配置想要监控的应用名称；2. 当clusterNameExpression: default时，turbine.aggregator.clusterConfig可以不写，因为默认就是default；3. 当clusterNameExpression: metadata[‘cluster’]时，假设想要监控的应用配置了eureka.instance.metadata-map.cluster: ABC，则需要配置，同时turbine.aggregator.clusterConfig: ABC 启动类添加@EnableTurbine，激活对Turbine的支持 123456789@SpringBootApplication@EnableTurbinepublic class EurekaMonitorClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaMonitorClientApplication.class, args); &#125;&#125;","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"/categories/Spring-Cloud/"}],"tags":[]},{"title":"Feign","slug":"Feign","date":"2019-01-08T12:42:41.000Z","updated":"2019-01-09T13:47:14.516Z","comments":true,"path":"2019/01/08/Feign/","link":"","permalink":"/2019/01/08/Feign/","excerpt":"","text":"编写Feign客户端增加Feign的起步依赖spring-cloud-starter-feig、Eureka Client的起步依赖spring-cloud-starter-eureka、Web功能的起步依赖spring-boot-starter-web，pom文件如下： 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置application.yml。 123456789server: port: 8765spring: application: name: eureka-feign-clienteureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 在程序启动类EurekFeignClientApplication加上注解@EnableEurekaClient开启Eureka Client的功能，通过注解@EnableFeignClients开启Feign Client的功能。 12345678910@SpringBootApplication@EnableEurekaClient@EnableFeignClientspublic class EurekaFeignClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaFeignClientApplication.class, args); &#125;&#125; 通过以上3个步骤，该程序就具备了Feign的功能。 新建一个EurekaClientFeign的接口，在接口加上@FeignClient来声明一个Feign Client，其中value为远程调用其他服务的服务名，FeignConfig.class为Feign Client的配置类。在接口内部有一个sayHiFromClientEureka()方法，该方法通过Feign来调用eureka-client服务的”/hi”的API接口。 12345@FeignClient(value = \"eureka-client\", configuration = FeignConfig.class)public interface EurekaClientFeign &#123; @GetMapping(value = \"/hi\") String sayHiFromClientEureka(@RequestParam(value = \"name\") String name);&#125; 在FeignConfig类加上@Configuration注解，表明该类是一个配置类，并注入一个BeanName为feignRetryer的Retryer的Bean。注入该Bean之后，Feign在远程调用失败后会进行重试。 123456789import static java.util.concurrent.TimeUnit.SECONDS;@Configurationpublic class FeignConfig &#123; @Bean public Retryer feignRetryer()&#123; return new Retryer.Default(100, SECONDS.toMillis(1), 5); &#125;&#125; 在service层注入EurekaClientFeign的Bean。 12345678910@Servicepublic class HiService &#123; @Autowired EurekaClientFeign eurekaClientFeign; public String sayHi(String name)&#123; return eurekaClientFeign.sayHiFromClientEureka(name); &#125;&#125; 在HiController层注入并调用sayHi()方法。 1234567891011@RestControllerpublic class HiController &#123; @Autowired HiService hiService; @GetMapping(\"/hi\") public String sayHi(@RequestParam(defaultValue = \"zhangsan\", required = false) String name)&#123; return hiService.sayHi(name); &#125;&#125; 访问http://localhost:8765/hi 1hi zhangsan, i am from port 8762 Feign源码实现过程1.首先通过@EnableFeignClients注解开启FeignClient的功能。只有这个注解存在，才会在程序启动时开启对@FeignClient注解的包扫描。 2.根据Feign的规则实现接口，并在接口上面加上@FeignClient注解。 3.程序启动后，会进行包扫描，扫描所有的@FeignClient的注解的类，并将这些信息注入IoC容器中。 4.当接口被调用时，通过JDK的代理来生成具体的RequestTemplate模版对象。 5.根据RequestTemplate再生产Http请求的Request对象。 6.Request对象交给Client去处理，其中Client的网络请求框架可以是HttpURLConnection、HttpClient、OkHttp。 7.最后Client被封装到LoadBalanceClient类，这个类结合类Ribbon做到了负载均衡。","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"/categories/Spring-Cloud/"}],"tags":[]},{"title":"Ribbon","slug":"Ribbon","date":"2019-01-07T13:20:18.000Z","updated":"2019-01-08T12:41:06.141Z","comments":true,"path":"2019/01/07/Ribbon/","link":"","permalink":"/2019/01/07/Ribbon/","excerpt":"","text":"RestTemplateRestTemplate是Spring Resources中一个访问第三方RESTful API接口的网络请求框架。RestTemplate是用来消费REST服务的，所以RestTemplate的主要方法都与REST的Http协议的一些方法紧密相连，例如HEAD、GET、POST、DELETE和OPTIONS等方法，这些方法在RestTemplate类对应的方法为headForHeaders()、getForObject()、postForObject()、put()和delete()等。以下代码可以将返回的JSON字符串转换成一个User对象。 1User user = restTemplate.getForObject(\"https://www.xxx.com/\", User.class); Ribbon负载均衡是指将负载分摊到多个执行单元上，常见的负载均衡有两种方式。一种是独立进程单元，通过负责均衡策略，将请求转发到不同的执行单元上，例如Ngnix。另一种是将负载均衡逻辑以代码的形式封装到服务消费者的客户的，服务消费者客户端维护了一份服务提供者的信息列表。有了信息列表，通过负载均衡策略将请求分摊给多个服务提供者，从而达到负载均衡的目的。 目前NetFlix用于生产环境的Ribbon子模块： ribbon-loadbalancer：可以独立使用或与其他模块一起使用的负载均衡器API。 ribbon-eureka：Ribbon结合Eureka客户端的API，为负载均衡器提供动态服务注册列表。 ribbon-core：Ribbon的核心API。 使用RestTemplate和Ribbon来消费服务引入Eureka Client的起步依赖spring-cloud-starter-eureka、Ribbon的起步依赖spring-cloud-starter-ribbon，以及Web的起步依赖spring-boot-starter-web。 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 配置application.yml，指定程序名、端口号、服务注册地址。 123456789spring: application: name: eureka-ribbon-clientserver: port: 8764eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 作为Eureka Client需要在程序的入口类加上注解@EnableEurekaClient开启Eureka Client功能。 123456789@SpringBootApplication@EnableEurekaClientpublic class EurekaRibbonClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaRibbonClientApplication.class, args); &#125;&#125; 写一个RESTful API接口，在该API接口内部需要调用eureka-client的API接口”/hi”，即服务消费。这时需要将RestTemplate和Ribbon相结合，进行负载均衡。 需要在程序的IoC容器中注入一个restTemplate的Bean，并在这个Bean上加上@LoadBalanced注解，此时RestTemplate就结合了Ribbon开启了负载均衡功能。 12345678@Configurationpublic class RibbonConfig &#123; @Bean @LoadBalanced RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 写一个RibbonService类，在该类的hi()方法用restTemplate调用eureka-client的API接口，此时Uri不需要使用硬编码(如ip)，只需要写服务名即可。 123456789@Servicepublic class RibbonService &#123; @Autowired RestTemplate restTemplate; public String hi(String name)&#123; return restTemplate.getForObject(\"http://eureka-client/hi?name=\"+name, String.class); &#125;&#125; 写RibbonController，调用servcie的方法。 123456789101112@RestControllerpublic class RibbonController &#123; @Autowired RibbonService ribbonService; @GetMapping(\"/hi\") public String hi(@RequestParam(required = false, defaultValue = \"zhangsan\") String name)&#123; return ribbonService.hi(name); &#125;&#125; LoadBalanceClient负载均衡器的核心类为LoadBalanceClient，LoadBalanceClient可以获取负载均衡的服务提供者的实例信息。 获取Eureka Client的实例信息时： 123456789101112@RestControllerpublic class RibbonController &#123; @Autowired private LoadBalancerClient loadBalancerClient; @GetMapping(\"/testRibbon\") public String testRibbon()&#123; ServiceInstance instance = loadBalancerClient.choose(\"eureka-client\"); return instance.getHost() + \":\" + instance.getPort(); &#125;&#125; 不从Eureka Client获取注册列表信息时： 在启动类中增加@SpringBootApplication注解。 配置文件application.yml，配置ribbon.eureka.enable为false来禁止调用Eureka Client获取注册列表。配置程序名为stores的服务，通过stores.ribbon.listOfServers来配置这些服务实例的Url。 12345678stores: ribbon: listOfServers: example.com,google.comribbon: eureka: enabled: falseserver: port: 8769 新建RestController类。 123456789101112@RestControllerpublic class RibbonController &#123; @Autowired private LoadBalancerClient loadBalancerClient; @GetMapping(\"/testRibbon\") public String testRibbon()&#123; ServiceInstance instance = loadBalancerClient.choose(\"stores\"); return instance.getHost() + \":\" + instance.getPort(); &#125;&#125; 在浏览器上多次访问http://localhost:8769/testRibbon，浏览器会交替出现以下内容： 12example.com:80google.com:80 在Ribbon中的负载均衡客户端为LoadBalancerClient，在Spring Cloud项目中，负载均衡器Ribbon会默认从Eureka Client的服务注册列表中获取服务的信息，并缓存一份。如果禁止从Eureka获取注册列表信息，则需要自己维护一份服务注册列表信息。","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"/categories/Spring-Cloud/"}],"tags":[]},{"title":"Eureka","slug":"Eureka","date":"2019-01-05T13:13:26.000Z","updated":"2019-01-06T11:51:07.239Z","comments":true,"path":"2019/01/05/Eureka/","link":"","permalink":"/2019/01/05/Eureka/","excerpt":"","text":"Eureka简介什么是EurekaEureka是一个用于服务注册和发现的组件。Eureka分为Eureka Server和Eureka Client，Eureka Server为Eureka服务注册中心，Eureka Client为Eureka客户端。 Eureka的基本架构主要包括以下3种角色 Register Service:：服务注册中心，它是一个Eureka Server，提供服务注册和发现的功能 Provide Service：服务提供者，它是一个Eureka Client，提供服务 Consumer Service：服务消费者，它是一个Eureka Client，消费服务 Eureka Server在pom文件中引入Eureka Server依赖 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在application.yml中做配置。通过server.port制定Eureka Server的端口为8761。在默认情况下，Eureka Server 会向自己注册，这时需要配置eureka.client.registerWithEurkea和eureka.client.fetchRegistry为false，防止自己注册自己。 1234567891011server: port: 8761eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 在工程的启动类EurekaServerApplication加上注解@EnableEurekaServer，开启Eureka Server的功能。 123456789@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; Eureka Client在pom中引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 在bootstrap.yml做Eureka Client客户端的相关配置，配置了程序名为eureka-client，程序端口为8762，服务注册地址为http://localhost:8761/eureka/ 123456789server: port: 8762spring: application: name: eureka-clienteureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka 在程序的启动类加上@EnableEurekaClient开启Eureka Client功能 123456789@SpringBootApplication@EnableEurekaClientpublic class EurekaClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaClientApplication.class, args); &#125;&#125; Eureka概念 Register–服务注册 当Eureka Client向Eureka Server注册时，Eureka Client提供自身的元数据，比如IP地址、端口、运行状况指标的Url、主页地址等信息。 Renew–服务续约 Eureka Client在默认的情况下会每隔30秒发送一次心跳来进行服务续约。通过服务续约来告知Eureka Server该Eureka Client仍然可用，没有出现故障。 Fetch Registries–获取服务注册列表信息 Eureka Client从Eureka Server获取服务注册表信息，并将其缓存在本地。 Cancel–服务下线 Eureka Client在程序关闭时可以向Eureka Server发送下线请求。发送请求后，该客户端的实例信息将从Eureka Server的服务注册列表中删除。该下线请求不会自动完成，需要在程序中调用: 1DiscoveryManager.getInstance().shutdownComponent(); Eviction–服务剔除 在默认情况下，当Eureka Client连续90秒没有向Eureka Server发送服务续约(即心跳)时，Eureka Server会将该服务实例从服务注册列表中删除。","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"/categories/Spring-Cloud/"}],"tags":[]},{"title":"Spring Boot","slug":"Spring-Boot","date":"2018-12-17T13:44:39.000Z","updated":"2019-01-05T14:10:39.215Z","comments":true,"path":"2018/12/17/Spring-Boot/","link":"","permalink":"/2018/12/17/Spring-Boot/","excerpt":"","text":"@SpringBootApplication注解@SpringBootApplication开启了Spring的组件扫描和Spring Boot的自动配置功能呢。实际上，它将三个有用的注解组合在了一起。 @Configuration:标明该类使用Spring基于Java的配置。 @ComponentScan:启用组件扫描。 @EnableAutoConfiguration:开启自动配置。","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"/categories/Spring-Boot/"}],"tags":[]}]}